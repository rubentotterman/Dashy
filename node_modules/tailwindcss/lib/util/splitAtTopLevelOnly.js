<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> fde19de (Supabase initialization)
/**
 * This splits a string on a top-level character.
 *
 * Regex doesn't support recursion (at least not the JS-flavored version).
 * So we have to use a tiny state machine to keep track of paren placement.
 *
 * Expected behavior using commas:
 * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)
 *       ─┬─             ┬  ┬    ┬
 *        x              x  x    ╰──────── Split because top-level
 *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens
 *
 * @param {string} input
 * @param {string} separator
 */ "use strict";
<<<<<<< HEAD
=======
"use strict";
>>>>>>> b442312 (Initial commit)
=======
>>>>>>> fde19de (Supabase initialization)
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "splitAtTopLevelOnly", {
    enumerable: true,
<<<<<<< HEAD
<<<<<<< HEAD
    get: function() {
        return splitAtTopLevelOnly;
    }
});
function splitAtTopLevelOnly(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    let isEscaped = false;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (stack.length === 0 && char === separator[0] && !isEscaped) {
            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
                parts.push(input.slice(lastPos, idx));
                lastPos = idx + separator.length;
            }
        }
        isEscaped = isEscaped ? false : char === "\\";
        if (char === "(" || char === "[" || char === "{") {
            stack.push(char);
        } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
            stack.pop();
        }
    }
    parts.push(input.slice(lastPos));
    return parts;
=======
    get: ()=>splitAtTopLevelOnly
=======
    get: function() {
        return splitAtTopLevelOnly;
    }
>>>>>>> fde19de (Supabase initialization)
});
function splitAtTopLevelOnly(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    let isEscaped = false;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (stack.length === 0 && char === separator[0] && !isEscaped) {
            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
                parts.push(input.slice(lastPos, idx));
                lastPos = idx + separator.length;
            }
        }
        isEscaped = isEscaped ? false : char === "\\";
        if (char === "(" || char === "[" || char === "{") {
            stack.push(char);
        } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
            stack.pop();
        }
    }
<<<<<<< HEAD
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function* splitAtTopLevelOnly(input, separator) {
    let SPECIALS = new RegExp(`[(){}\\[\\]${_regex.escape(separator)}]`, "g");
    let depth = 0;
    let lastIndex = 0;
    let found = false;
    let separatorIndex = 0;
    let separatorStart = 0;
    let separatorLength = separator.length;
    // Find all paren-like things & character
    // And only split on commas if they're top-level
    for (let match of input.matchAll(SPECIALS)){
        let matchesSeparator = match[0] === separator[separatorIndex];
        let atEndOfSeparator = separatorIndex === separatorLength - 1;
        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;
        if (match[0] === "(") depth++;
        if (match[0] === ")") depth--;
        if (match[0] === "[") depth++;
        if (match[0] === "]") depth--;
        if (match[0] === "{") depth++;
        if (match[0] === "}") depth--;
        if (matchesSeparator && depth === 0) {
            if (separatorStart === 0) {
                separatorStart = match.index;
            }
            separatorIndex++;
        }
        if (matchesFullSeparator && depth === 0) {
            found = true;
            yield input.substring(lastIndex, separatorStart);
            lastIndex = separatorStart + separatorLength;
        }
        if (separatorIndex === separatorLength) {
            separatorIndex = 0;
            separatorStart = 0;
        }
    }
    // Provide the last segment of the string if available
    // Otherwise the whole string since no `char`s were found
    // This mirrors the behavior of string.split()
    if (found) {
        yield input.substring(lastIndex);
    } else {
        yield input;
    }
>>>>>>> b442312 (Initial commit)
=======
    parts.push(input.slice(lastPos));
    return parts;
>>>>>>> fde19de (Supabase initialization)
}
